<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="夏明儒 JavaScript CSS HTML">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="http://outqqzk4u.bkt.clouddn.com/img/study/github_blog/favicon.ico">

    <title>
        
          javascript语言精粹学习笔记 - 夏明儒的博客 | Mingru&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://mingrutough.github.io/2017/06/08/javascript-book1/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/mingru-blog.css">    

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top is-visible is-fixed">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Mingru’s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    <li>
                        <a href="/archives/">Archives</a>
                    </li>
                    <!--

                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    -->
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://mingrutough.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('http://outqqzk4u.bkt.clouddn.com/img/study/github_blog/home-bg.jpeg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#O&#39;REILLY" title="O&#39;REILLY">O&#39;REILLY</a>
                        
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                    </div>
                    <h1>javascript语言精粹学习笔记</h1>
                    <h2 class="subheading">好书都要看</h2>
                    <span class="meta">
                        Posted by mingrutough on
                        2017-06-08
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
    <!-- Post Container -->
            <div class="
                col-lg-8
                col-md-8
                col-md-offset-1
                col-md-offset-1                                                
                post-container">

                <p><img src="http://outqqzk4u.bkt.clouddn.com/img/study/github_blog/js_book1.png">
这是一本好书，好好看一下，记录一下。</p>
<p></p><h2>第二章 语法</h2><p></p>
<h4>字符串</h4>
(反斜线符号)是转义字符。转义字符用来把那些正常情况下不被允许的字符插入到字符串中，比如反斜线、引号、和控制字符。\u约定用来指定数字字符编码。字符串是不可变的，一旦字符串被创建，就永远无法改变它。但是可以很容易通过➕运算符连接其他字符串来创建一个新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同的字符串。

#### 语句 代码块 表达式 傻傻分得清
程序是由语句构成，语句则是由“；（分号）”分隔的句子或命令。一个编译单元包含一组可执行的语句。语句通常是按照从上到下的顺序被执行。javscript可以通过条件语句（if 和 switch）、循环语句（while、for、和do）、强制跳转语句（break、return、和throw）和函数调用来改变执行序列。

<b>代码块</b>是包在一对花括号中的一组<i>语句</i>。

最简单的<b>表达式</b>是字面量值（比如字符串或数字）、变量、内置的值（true、false、null、undefined、NaN和Infinity）、以new开头的调用表达式、以delete开头的属性提取表达式、包在圆括号中的表达式、以一个前置运算符作为前导的表达式等等。

上面是书中的内容，下面则是<a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687589.html" target="_blank" rel="external">紫云飞的翻译文章</a>中的内容。
&gt;JavaScript中的表达式和语句是有区别的.一个表达式会产生一个值,它可以放在任何需要一个值的地方,比如,作为一个函数调用的参数.下面的每行代码都是一个表达式: myvar , 3 + x , myfunc(“a”, “b”).语句可以理解成一个行为.循环语句和if语句就是典型的语句.一个程序是由一系列语句组成的.JavaScript中某些需要语句的地方,你可以使用一个表达式来代替.这样的语句称之为表达式语句.但反过来不可以:你不能在一个需要表达式的地方放一个语句.比如,一个if语句不能作为一个函数的参数.


#### 逻辑运算表达式得到的值
a &amp;&amp; b 以前我是傻傻的认为它返回的值只是一个布尔值。。。书中说道：如果第一个运算数a的值为假，那么运算符&amp;&amp;产生它的第一个运算数a的值，否则产生第二个运算数b的值。
<br><br>同样的，如果第一个运算符的值为真，那么运算符||产生第1个运算数的值，否则产生第二个运算符的值。

<h2>第三章 对象</h2>
<blockquote cite="">
    javascript 的简单数据类型包括字符串、数字、布尔值、null和undefined值。其他所有的值都是对象。
    对象是属性的容器，其中每个属性都拥有名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性的值可以是除undefined值之外的任何值。
</blockquote>
<h4>对象字面量</h4>
对象字面量是一种可以方便地按指定规格创建新对象的表示法。一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。对象字面量可以出现在任何允许表达式出现的地方。属性名可以是标识符或字符串，这些名字被当做字面量名而不是变量名来对待。所以对象的属性名在编译时才能知道，属性的值就是表达式。
<br>
在对象字面量中，如果属性名是一个合法的javascript标识符且不是保留字，则并不强制要求用引号括住属性名。所以用引号括住“first-name”是必需的，但是是否括住first_name是可选的。

#### &amp;&amp;的小小巧妙用法
在一个对象中，尝试从其undefined的成员属性中取值将会导致TypeError异常。这时可以通过&amp;&amp;运算符来避免错误。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">flight.equipment   <span class="comment">// undefined</span></div><div class="line">flight.equipment.model <span class="comment">// throw "TypeError"</span></div><div class="line">flight.equipment &amp;&amp; flight.equipment.model <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<h4>引用&amp;&amp;更新</h4>
对象通过引用来传递。对象里的值可以通过赋值语句来更新。如果属性名已经存在于对象里，那么这个属性的值就会被替换。如果对象之前没有拥有那个属性名，那么该属性就被扩充到对象中。

#### 手动实现Object.create()。
当你创建一个新对象的时候，你可以选择某个对象作为它的原型。es5 中通过Object.create方法实现了创建一个使用原对象作为其原型的新对象的方法。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">        F.prototype = obj;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub_obj = <span class="built_in">Object</span>.create(obj);</div></pre></td></tr></table></figure>

<h4>删除</h4>
delete运算符可以用来删除对象的属性。如果对象包含该属性，那么该属性就会被移除。它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性透露出来。

<h2>第四章 函数</h2>
<blockquote>函数包含一组语句，它们是javascript的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于指定对象的行为。一般来说，所谓编程，就是将一组需求分解成一组函数与数据结构的技能。</blockquote>

<h4>函数对象</h4>
javascript中的函数就是对象。对象是“名/值”对的集合并拥有一个连接到原型对象的隐藏连接。对象字面量产生的对象连接到Object.prototype。函数对象连接到Function.prototype（该原型对象本身连接到Object.prototype)。每个函数在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。
<br>
函数的与众不同之处在于它们可以被调用。

<h4>函数字面量</h4>
函数对象通过函数字面量来创建：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

函数字面量可以出现在任何允许表达式出现的地方。

<h4>函数调用</h4>
调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数：this和arguments。参数this的值取决于调用的模式。在js中一共有4种调用模式：方法调用模式、函数调用模式、构造器调用模式和apply调用模式。这些模式在如何初始化关键参数this上存在差异。
<br>
调用运算符是跟在任何产生一个函数值的表达式之后的一对圆括号。

<h4>方法调用模式</h4>
当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。如果调用表达式包含一个提取属性的动作(即包含一个.点表达式或[]下标表达式)，那么它就是被当做一个方法来调用。
<br>
方法可以使用this访问自己所属的对象，所以它能从对象中取值或对对象进行修改。这个“超级”延迟绑定(very late binding)使得函数可以对this高度复用。通过this可取得它们所属对象的上下文的方法称为公共方法。

<h4>函数调用模式</h4>
当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。以此模式调用函数时，this被绑定到全局对象。

<h4>构造器调用模式</h4>
javascript是一门基于原型继承的语言。如果在一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数prototype成员的新对象，同时this会被绑定到那个新对象上。
<br>
一个函数，如果创建的目的就是希望结合new前缀来调用，那它就被称为构造器函数。按照约定，它们保存在以大写格式命名的变量里。

<h4>Applly 调用模式</h4>
因为javascript是一门函数式的面向对象编程语言，所以函数可以拥有方法。apply方法让我们构建一个参数数组传递给调用函数。它也允许我们选择this的值。apply方法接受两个参数，第一个是要绑定给this的值，第二个就是一个参数数组。

<h4>返回</h4>
return 语句可用来使函数提前返回。当return被执行时，函数立即返回而不再执行余下的语句。一个函数总是会返回一个值。如果没有指定返回值，则返回undefined。如果函数调用时在前面加上了new前缀，且返回值不是一个对象，则返回this（该新对象）。

<h4>闭包</h4>
作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量。一个更有趣的情形是内部函数拥有比它的外部函数更长的生命周期。
<br>
为了避免下面的问题，理解内部函数能访问外部函数的实际变量而无须复制是很重要的。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 构造一个函数，以错误的方式给一个数组中的节点设置事件处理程序。</span></div><div class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span> (<span class="params">nodes</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</div><div class="line">        nodes[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

上面函数的本意是想传递给每个事件处理器一个唯一值i。但它未能达到目的，<em>因为事件处理器函数绑定了变量i本身，而不是函数在构造时的变量i的值。</em>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 改良后，</span></div><div class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span> (<span class="params">nodes</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helper=<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</div><div class="line">        nodes[i].onclick=helper(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<h4>模块</h4>
<blockquote>我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态以及实现的函数或对象。通过使用函数产生模块，我们几乎可以完全摒弃全局变量的使用，从而缓解这个javascript中最为糟糕的特性之一所带来的影响</blockquote>
模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问到的地方。

<h4>级联</h4>
有一些方法没有返回值。如果我们让这些方法返回this而不是undefined。就可以启用<em>级联</em>。在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。

<h4>记忆</h4>
函数可以将先前操作的结果记录在某个对象里。从而避免无谓的重复运算。这种优化被称为记忆。
普通的递归实现的斐波拉切数列函数如下：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fibonacci=<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> n&lt;<span class="number">2</span>?n:fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

这种方式是可以工作的，但在多次调用该函数的情况下，它做了很多无谓的工作，每次都需要重新计算之前计算过的值。
<br><br>我们在一个名为memo的数组里保存我们的存储结果，存储结果可以隐藏在闭包中。当函数被调用时，这个函数首先检查结果是否存在，如果存在，就立即返回这个结果。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fibonacci=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> memo=[<span class="number">0</span>,<span class="number">1</span>];</div><div class="line">    <span class="keyword">var</span> fib=<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> result=memo[n];</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> result!==<span class="string">'number'</span>)</div><div class="line">        &#123;</div><div class="line">            result=fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</div><div class="line">            memo[n]=result;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> fib;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>

<h2>第五章 继承</h2>
<blockquote>javascript的原型存在着诸多矛盾。它的某些复杂的语法看起来就像那些基于类的语言，这些语法问题掩盖了它的原型机制。它不直接让对象从其他对象继承，反而插入了一个多余的间接层：通过构造器函数产生对象。</blockquote>

当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.prototype = &#123;<span class="attr">constructor</span>: <span class="keyword">this</span>&#125;;</div></pre></td></tr></table></figure>

新函数对象会被赋予一个prototype属性，它的值是一个包含constructor属性且属性值为该新函数的对象。这个prototype对象就是存放继承特征的地方。
<br><br>当采用构造器调用模式，即用new前缀去调用一个函数时，函数执行的方式会被修改。如果new运算符是一个方法而不是一个运算符，它可能会像这样执行。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Function</span>.method(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//method方法是书中实现的为Function添加原型方法的方法。</span></div><div class="line">    <span class="comment">//创建一个新对象，它继承自构造器函数的原型对象</span></div><div class="line">    <span class="keyword">var</span> that = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</div><div class="line">    <span class="comment">//调用构造器函数，绑定 this 到新对象上</span></div><div class="line">    <span class="keyword">var</span> other=<span class="keyword">this</span>.apply(that,<span class="built_in">arguments</span>);<span class="comment">//这个this指向的是构造器函数。如果该构造器函数有返回值，且返回值是对象则返回这个对象，要不然返回新对象。</span></div><div class="line">    <span class="comment">//如果它的返回值不是一个对象，就返回该新对象</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> other ===<span class="string">'object'</span>&amp;&amp;other)||that;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

<h4>函数化</h4>
迄今为止，我们看到的继承模式的一个弱点就是没法保护隐私。对象的所有属性都是可见的。要解决这个问题，我们从构造一个生成对象的函数开始。我们以小写字母开头来命名它，因为它并不需要使用new前缀。该函数包括四个步骤：
1.创建一个新对象。<br>
2.有选择的定义私有实例变量和方法。这些就是函数中通过var语句定义的普通变量。<br>
3.给这个新对象扩充方法。这些方法拥有特权去访问参数，以及在第二步中通过var语句定义的变量。
4.返回那个对象。
这里是一个函数化构造器的伪代码模板
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">constructor</span> = function(spec, my)&#123;</div><div class="line">    <span class="keyword">var</span> that, 其他的私有实例变量；</div><div class="line">    my = my||&#123;&#125;;</div><div class="line">    把共享的变量和函数添加到my中。</div><div class="line">    that = 一个新对象</div><div class="line">    添加给that的特权方法。</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

spec对象包含构造器需要构造一个新实例的所有信息。my对象是一个为继承链中的构造器提供秘密共享的容器。
下面是一个函数化构造器的应用
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mammal=<span class="function"><span class="keyword">function</span>(<span class="params">spec</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> that=&#123;&#125;;</div><div class="line">    that.get_name=fuction()&#123;</div><div class="line">        <span class="keyword">return</span> spec.name;</div><div class="line">    &#125;;</div><div class="line">    that.says=fuction()&#123;</div><div class="line">        <span class="keyword">return</span> spec.saying||<span class="string">""</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myMammal=mammal(&#123;<span class="attr">name</span>:<span class="string">"herb"</span>&#125;);</div></pre></td></tr></table></figure>

在函数化构造器中，定义一个构造器函数cat去继承mammal：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> cat=<span class="function"><span class="keyword">function</span>(<span class="params">spec</span>)</span>&#123;</div><div class="line">    spec.saying=spec.saying||<span class="string">'memow'</span>;</div><div class="line">    <span class="keyword">var</span> that=mammal(spec);</div><div class="line">    that.get_name=fuction()&#123;</div><div class="line">        <span class="keyword">return</span> that.says()+<span class="string">''</span>+spec.name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> that;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myCat=cat(&#123;<span class="attr">name</span>:<span class="string">'xiix'</span>&#125;);</div></pre></td></tr></table></figure>

函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们得到更好的封装和信息隐藏，以及访问父类方法的能力。
<br>
如果对象的所有状态都是私有的，那么该对象就成为一个“防伪”对象。该对象的属性可以被替换或删除，但该对象的完整性不会受到损害。如果我们用函数化的样式创建一个对象，并且该对象的所有方法都不使用this或that，那么该对象就是持久性的。一个持久性对象就是一个简单功能函数的集合。
一个持久性的对象不会被入侵。访问一个持久性的对象时，除非有方法授权，否则攻击者不能访问对象的内部状态。

<h2>第六章 数组</h2>
<blockquote>数组是一段线性分配的内存，它通过整数计算偏移并访问其中的元素。数组是一种性能出色的数据结构。不幸的是，javascript没有像此类数组一样的数据结构。
    <br>
    作为替代，javascript提供了一种拥有一些类数组特性的对象。它把数组的下标转变成字符串，用其作为属性。它明显的比一个真正的数组慢，但它用起来方便。它的属性的检索和更新的方式与对象一模一样，只不过多一个可以用整数作为属性名的特性。数组有自己的字面量格式。数组也有一套非常有用的内置方法。
</blockquote>

<h4>数组字面量</h4>
数组字面量提供了一种非常方便地创建新数组的表示法。一个数组字面量是在一对方括号中包围零个或者多个用逗号分隔的值的表达式。数组字面量允许出现在任何表达式可以出现的地方。数组的第一个值将获得属性名’0’，第二个值将获得属性名’1’，以此类推。
<br>
有一个很好的方式去判断一个对象是否是数组：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> is_array=<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.apply(value)===<span class="string">'[object Array]'</span>; <span class="comment">// 注意使用value.toString()一般没有效果，因为value的父类型一般重写了toString()方法。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

注意：使用instanceof 和constructor 判断变量的类型的时候，变量必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；
 <br>
原因：
<br>
1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。
<br>
2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！

<h2>第七章 正则表达式</h2>
<blockquote>正则表达式是一门简单语言的语法规范。它应用在一些方法中，对字符串的信息实现查找、替换和提取操作。可处理正则表达式的方法有regexp.exec、regexp.test、string.match、string.replace、string.search和string.split。通常来说，在javascript中正则表达式相较于等效的字符串处理有着显著的优势。</blockquote>

<b>下面内容来自javascript高级程序设计。</b>
<h4>RegExp类型</h4>
ECMAScript通过RegExp类型来支持正则表达式，使用下面的类似Perl的语法，就可以创建一个正则表达式。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> expression = <span class="regexp">/pattern/</span>flags;</div></pre></td></tr></table></figure>

其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一个或多个标志(flag)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。
g: 表示全局模式，即模式将被用于所有字符串，而非发现第一个匹配项时立即停止；<br>
i: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写；<br>
m: 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项。
<br>
因此，一个正则表达式就是一个模式与上述3个标志的组合体。

<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern1=<span class="regexp">/at/g</span>; <span class="comment">// 匹配字符串中所有"at"的实例 </span></div><div class="line"><span class="keyword">var</span> pattern2=<span class="regexp">/[bc]at/i</span>; <span class="comment">//匹配第一个"bat"或"cat"，不区分大小写。</span></div><div class="line"><span class="keyword">var</span> pattern3=<span class="regexp">/.at/gi</span>; <span class="comment">// 匹配所有以"at"结尾的3个字符的组合，不区分大小写。</span></div></pre></td></tr></table></figure>

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br>
( [ { \ ^ $ | ) ? * + . ] }   <br>
这些元字符在正则表达式中都有一种或多种特殊用途。因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern2=<span class="regexp">/\[bc\]at/i</span>; <span class="comment">//匹配第一个"[bc]at"，不区分大小写。</span></div><div class="line"><span class="keyword">var</span> pattern3=<span class="regexp">/\.at/gi</span>; <span class="comment">// 匹配所有".at"，不区分大小写。</span></div></pre></td></tr></table></figure>

前面的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方法是使用RegExp构造函数。它接受两个参数，一个是要匹配的字符串模式，另一个是可选的标志字符串。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。
<h4>RegExp实例属性</h4>
RegExp的每个实例都具有下列属性。通过这些属性可以取得有关模式的各种信息。
<ul>
    <li>global
        <br>
        布尔值，表示是否设置了g标志
    </li>
    <li>ignoreCase
        <br>
        布尔值，表示是否设置了i标志
    </li>
    <li>lastIndex
        <br>
        整数，表示开始搜索下一个匹配项的字符位置，从0算起
    </li>
    <li>multiline
        <br>
        布尔值，表示是否设置了m标志
    </li>
    <li>source
        <br>
        正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
    </li>
</ul>

<h4>RegExp实例方法</h4>

<ul>
    <li>
        exec() <br>
        该方法是专门为捕获组而设计的。它接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但它包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项。)
        对于exec()方法来说，即使在模式中设置了全局标志，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。

    </li>
    <li>test() <br>
        它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。

    </li>
</ul>

<p><b>下面回到该书上的内容</b>
<br>
（？：…）表示一个非捕获型分组。（…）表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并将其放到result数组里。每个捕获型分组都会被指定一个编号。第一个捕获型分组的编号是1，所以该分组所匹配的文本副本将会出现在result[1]中。
<br>
[…]表示一个字符类。[A-Za-z]这个字符类包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。 
<br>    </p>
<p></p><h2>一个匹配数字的正则表达式</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> parse_number=<span class="regexp">/^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i</span>;</div><div class="line"><span class="keyword">var</span> is_number=parse_number.test(<span class="string">'11'</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure><p></p>
<p>让我们来分解parse_number：
<br>
/^ $/i 
<br>
我们用^和$来框定这个正则表达式。它指引这个正则表达式对文本中的所有字符都进行匹配，如果我们省略了这些标识，那么只要一个字符串包含一个数字，这个正则表达式就会进行匹配。但是有了这些标识，只有当一个字符串中的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^，它将匹配以一个数字开头的字符串，如果我们仅包含$，则匹配以一个数字结尾的字符串。
<br>
-?  负号后面的后缀表示这个负号是可选的。<br><br>\d 的含义和[0-9]一样。它匹配一个数字，后缀+指引它可以匹配一个或者多个数字。<br>
(?:.\d*)? (?: …)?表示了一个可选的非捕获型分组。通常用非捕获型分组来代替少量不优美的捕获型分组是很好的办法，因为捕获会有性能上的损失。这个分组会匹配后面跟随的0个或者多个数字的小数点。<br> 
(?:e[+-]?\d+)? 这是另外一个可选的非捕获型分组。它会匹配一个e(或E)、一个可选的正负号以及一个或者多个数字。
<br>
RegExp构造器适用于必须在运行时动态生成正则表达式的情形。注意，用正则表达式字面量创建RegExp对象共享同一个单例。</p>
<h4>构成正则表达式的元素</h4>

<ul>
    <li>正则表达式分支
        <br>
        一个正则表达式分支包含一个或多个正则表达式序列。这些序列被|(竖线)字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就会被匹配。它尝试按顺序依次匹配这些序列项。所以：<br><br>        “into”.match(/in|int/);  会在into中匹配in。但它不会匹配int,因为in已经被成功匹配了。
    </li>
    <li>正则表达式序列
        <br>
        一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数。如果没有指定这个量词，那么该因子只会被匹配一次。
    </li>
    <li>正则表达式因子
        <br>
        一个正则表达式因子可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和特殊字符以外，所有的字符都会被按照字面处理。<br><br>        ( [ { \ ^ $ | ) ? * + . ] } 如果你希望左边列出来的字符按字面去匹配，那么必须要用一个\前缀来进行转义。你如果拿不准的话，可以给任何特殊字符都添加一个\前缀来使其字面化。注意\前缀不能使字母或者数字字面化。<br>
        一个未被转义的 . 会匹配除行结束符之外的任何字符。当lastIndex属性值为0的时候，一个未转义的^会匹配文本的开始。当指定了m标识时，它也能匹配行结束符。一个未转义的$将匹配文本的结束，当指定了m标识时，它也能匹配行结束符。
    </li>
    <li>正则表达式转义
        <br>
        反斜杠字符在正则表达式因子中与其在字符串中一样均表示转义。但是稍有不同。<br>
        \d 等同于[0-9]，它匹配一个数字。\D则表示与其相反的： [^0-9] （即匹配0-9之外的字符）
        <br>
    </li>
</ul>

<p></p><h4>正则表达式分组</h4><p></p>
<ul>
    <li>捕获型
        <br>
        一个捕获型分组是一个被包围在圆括号中的正则表达式分支。任何匹配这个分组的字符都会被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第一个捕获(的是分组一，以此类推。

    </li>
    <li>非捕获型
        <br>
        非捕获型分组有一个(?:前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配的内容，这会带来微弱的性能优势。非捕获型分组不会干扰捕获型分组的编号。
    </li>
</ul>

<p></p><h4>正则表达式字符集</h4>
正则表达式字符集是一种指定一组字符的便利方式。例如，如果想匹配一个元音字母，我们可以写做(?:a|e|i|o|u),但它可以被更方便地写成一个类[aeiou]。在一个级联中，我们可以在单独一条语句中依次调用同一个对象的很多方法。
<br>
类提供另外两个便利。第一个是能够指定字符范围。比如[0-9]。另一个方便之处就是类的取反。如果[后的第一个字符是^，那么这个类会排除这些特殊字符。<p></p>
<p></p><h4>正则表达式量词</h4>
正则表达式因子可以用一个正则表达式量词后缀来决定这个因子应该被匹配的次数。包围在一对花括号中的一个数字表示这个因子应该被匹配的次数。所以，/www/匹配的和/w{3}/一样，{3，6}会匹配3、4、5或6次。{3,}会匹配3次或更多次。<br>
?等同于{0,1}，*等同于{0，}，+等同于{1，}。如果只有一个量词，表示趋向于进行贪婪性匹配，即匹配尽可能多的副本直至达到上限。如果这个量词附加一个后缀？，则表示趋向于进行非贪婪匹配，即只要匹配必要的副本就好。一般情况下最好坚持使用贪婪性匹配。<p></p>
<p></p><h2>第八章 方法</h2><p></p>
<p></p><h2>Array</h2><p></p>
<ul>
    <li>array.concat(item…)
         <br>
         concat方法产生一个新数组，它包含一份array的浅复制并把一个或多个参数item附加在其后，如果参数item是一个数组，那么它的每个元素会被分别添加。
    </li>
    <li>array.join(separator)
         <br>
         join方法把一个array构造成一个字符串。它先把array中的每个元素构造成一个字符串，接着用一个separator分隔符把它们连接在一起，默认的separator是逗号‘,’。要想做到无间隔的连接，我们可以使用空字符串作为separator。

    </li>
    <li>array.pop()
        <br>
        pop和push方法使得数组array可以像堆栈一样工作。pop方法移除array中的最后一个元素并返回该元素。如果array是empty，它会返回undefined。
        pop可以像这样实现：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Array</span>.method(<span class="string">'pop'</span>,fucntion()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.splice(<span class="keyword">this</span>.length<span class="number">-1</span>,<span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

    </li>
    <li>array.push(item…)
        <br>
        push方法把一个或多个参数item附加到一个数组的尾部。和concat方法不同的是，它会修改array，如果参数item是一个数组，它会把参数数组作为单个元素整个添加到数组中，并返回这个数组的新长度值。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Array</span>.method(<span class="string">'push'</span>,fucntion()&#123;</div><div class="line">    <span class="keyword">this</span>.splice.apply(<span class="keyword">this</span>,</div><div class="line">        [<span class="keyword">this</span>.length,<span class="number">0</span>].concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

    </li>
    <li>array.reverse()
         <br>
         reverse方法反转array里的元素的顺序，并返回array本身；
    </li>
    <li>array.shift()
         <br>
         shift方法移除数组array中的第一个元素并返回这个元素。如果该数组为空，则返回undefined。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Array</span>.method(<span class="string">'shift'</span>,fucntion()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.splice(<span class="number">0</span>,<span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">&#125;);</div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line"><span class="string">    &lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;array.slice(start,end)</span></div><div class="line"><span class="string">        &lt;br&gt;</span></div><div class="line"><span class="string">        slice方法对array中的一段做浅复制。首先复制array[start],一直复制到array[end]为止。end参数是可选的，默认值是该数组的长度array.length。如果两个参数中的任何一个是负数。array.length会和它们相加，试图让他们成为非负数。如果start大于等于array.length，得到的结果将是一个空数组。注意，slice不改变原数组的值。</span></div><div class="line"><span class="string">    &lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;array.sort(comparefn)</span></div><div class="line"><span class="string">        &lt;br&gt;</span></div><div class="line"><span class="string">        sort方法对array中的内容进行排序。它不能正确地给一组数字排序，因为javascript的默认比较函数把要排序的元素都视为字符串。</span></div><div class="line"><span class="string">        &lt;br&gt;</span></div><div class="line"><span class="string">        比较函数可以自己来定制。你的比较函数应该接受两个参数，并且如果这两个参数相等则返回0，如果第一个参数应该排列在前面，则返回一个负数。如果第二个参数应该排列在前面，则返回一个正数。</span></div><div class="line"><span class="string">    &lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;array.slice(start,deleteCount,item...)</span></div><div class="line"><span class="string">         &lt;br&gt;</span></div><div class="line"><span class="string">         splice方法从array中移除一个或多个元素，并用新的item来替换他们。参数start是从数组array中移除元素的开始位置。参数deleteCount是要移除的元素个数。如果有额外的参数，那么item会插入到被移除元素的位置上。它返回被移除元素的数组。</span></div><div class="line"><span class="string">    &lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;array.unshift(item...)</span></div><div class="line"><span class="string">         &lt;br&gt;</span></div><div class="line"><span class="string">         unshift方法像push方法一样，用于把元素添加进数组中，但它是把item插入到array的开始部分而不是尾部。它返回新的length。</span></div><div class="line"><span class="string">`</span><span class="string">``</span>js </div><div class="line"><span class="built_in">Array</span>.method(<span class="string">'unshift'</span>,fucntion()&#123;</div><div class="line">    <span class="keyword">this</span>.splice.apply(<span class="keyword">this</span>,</div><div class="line">        [<span class="number">0</span>,<span class="number">0</span>].concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

    </li>
</ul>

<p></p><h2>Function</h2><p></p>
<ul>
    <li>function.apply(thisArg, argArray)
        apply方法调用function，传递一个会被绑定到函数内this上的对象和一个可选的数组作为参数。apply方法被用于apply调用模式中。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Function</span>.method(<span class="string">'bind'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">that</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> method = <span class="keyword">this</span>,</div><div class="line">    slice=<span class="built_in">Array</span>.prototype.slice,</div><div class="line">    args=slice.apply(<span class="built_in">arguments</span>,[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> method.apply(that,</div><div class="line">                            args.concat(slice.apply(<span class="built_in">arguments</span>,[<span class="number">0</span>])));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

    </li>
</ul>
<h2>Number</h2>
<ul>
    <li>number.toExponential(fractionDigits)
        <br>
        toExponential方法把这个number转换成一个指数形式的字符串。可选参数fractionDigits控制其小数点后的数字位数。它的值必须在0-20；
    </li>
    <li>number.toFixed(fractionDigits)
        <br>
        toFixed方法把这个number转换成一个十进制数形式的字符串。可选参数fractionDigits控制其小数点后的数字位数。它的值必须在0-20，默认为0；
    </li>
    <li>number.toPrecision(precision)
        <br>
        toPrecision方法把这个number转换成一个十进制数形式的字符串。可选参数precision控制其数字的精度。它的值必须在0-21。
    </li>
    <li>number.toString(radix)
         <br>
         该方法把这个number转换成一个字符串。可选参数radix控制基数。它的值必须在2-36.默认的radix是以10为基数的。
    </li>
</ul>
<h2>Object</h2>
<ul>
    <li>object.hasOwnProperty(name)
         <br>
         如果这个object包含一个名为name的属性，那么hasOwnProperty方法返回true。原型链中的同名属性是不会被检查的。
    </li>
</ul>
<h2>RegExp</h2>
<ul>
    <li>regexp.exec(string)
         <br>
         exec方法是使用正则表达式的最强大（和最慢）的方法。如果它成功地匹配regexp和字符串string，它会返回一个数组。数组中下标为0的元素将包含正则表达式regexp匹配的子字符串。下标为1的元素是分组1捕获的文本，以此类推。
    </li>
    <li>regexp.test(string)
         <br>
         test方法是使用正则表达式的最简单(最快)的方法。如果该regexp匹配string，它返回true；否则，它返回false；
    </li>
</ul>
<h2>String</h2>
<ul>
    <li>string.replace(searchValue, replaceValue)
        <br>
        replace方法对string进行查找和替换操作，并返回一个新的字符串。参数searchValue可以是一个字符串或一个正则表达式或一个正则表达式对象。如果它是一个字符串，那么searchValue只会在第一次出现的地方被替换。<br>
        如果searchValue是一个正则表达式并且带有g标识，它会替换所有的匹配。如果没有带g标识，它会仅替换第一个匹配。
        <br>
        replaceValue可以是一个字符串或一个函数。如果replaceValue是一个字符串，字符$拥有特别的含义。
    </li>
</ul>

<p></p><h2>JSON</h2><p></p>
<p><blockquote>javascript对象表示法(json)是一种轻量级的数据交换格式。它是基于javascript的对象字面量表示法。</blockquote></p>
<p></p><h4>json语法</h4>
json有6种类型的值：对象、数组、字符串、数字、布尔值和特殊值null。<br><br>json对象是一个容纳“名/值”对的无序集合。名字可以是任何字符串，值可以是任何类型的json值，包括数组和对象。
<br>
json数组是一个值得有序序列，其值可以是任何类型的json值，包括数组和对象。
<br>
json字符串被包围在一对双引号之间。<p></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2017/10/25/useful-articals/" data-toggle="tooltip" data-placement="top" title="有用的文章合集">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2017/06/08/javascript-book2/" data-toggle="tooltip" data-placement="top" title="JavaScript权威指南">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-3
                col-md-3
                col-md-offset-0
                col-md-offset-0
                hidden-xs	
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">目录</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#O&#39;REILLY" title="O&#39;REILLY">O&#39;REILLY</a>
                        
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    // async("https://cdn.bootcss.com/anchor-js/4.1.0/anchor.min.js",function(){
    //     anchors.options = {
    //       visible: 'always',
    //       placement: 'left',
    //       icon: ''
    //     };
    //     // anchors.add();
    //     // anchors.add('.post-container h1, .post-container h2, .post-container h3, .post-container h4');
    //     simpleNav();
    // })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>




    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mingru’s Blog 2018 
                    <br>
                    <!--Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>-->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://mingrutough.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        console.log(a);
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        // $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: true,
            easing: "swing",
            filter: "",
            scrollSpeed: 500,
            scrollOffset: 0,
            scrollThreshold: .5,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });    

    function catalogPosition(){
        
    };
    var catTopDis = $('.catalog-container').offset().top; // 导航距离顶部距离(position不为fixed时) 
    var catLeftDis = $('.catalog-container').offset().left; // 导航距离顶部距离(position不为fixed时)  
    navFixed();
    $(document).on('scroll',navFixed);
    function navFixed(){ // 根据当前页面滚动情况固定导航栏
        var scrollHeight = $(document).scrollTop();         
        if(scrollHeight > catTopDis){
            if(!$('.catalog-container').hasClass('catalog-fixed')) {
                $('.catalog-container').addClass('catalog-fixed').css('left',catLeftDis); ;
            } 
                
        } else{
            if($('.catalog-container').hasClass('catalog-fixed')) {                       
                $('.catalog-container').removeClass('catalog-fixed').css('left',0); ;

            } 
        }
    }
    // $(window).on('resize',function(){
    //     catTopDis = $('.catalog-container').offset().top; // 导航距离顶部距离(position不为fixed时) 
    //     catLeftDis = $('.catalog-container').offset().left; // 导航距离顶部距离(position不为fixed时)  
    // });
</script>




<!-- Image to hack wechat -->
<!--<img src="https://mingrutough.github.io/img/icon_wechat.png" width="0" height="0" />-->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
