<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="夏明儒 JavaScript CSS HTML">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="http://outqqzk4u.bkt.clouddn.com/img/study/github_blog/favicon.ico">

    <title>
        
          阮一峰老师博客阅读记录 - 夏明儒的博客 | Mingru&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://mingrutough.github.io/2017/12/13/ruanyifeng-articals/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/mingru-blog.css">    

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top is-visible is-fixed">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Mingru’s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    <li>
                        <a href="/archives/">Archives</a>
                    </li>
                    <!--

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    -->
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://mingrutough.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('http://outqqzk4u.bkt.clouddn.com/img/study/github_blog/home-bg.jpeg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                          <a class="tag" href="/tags/#大牛博客" title="大牛博客">大牛博客</a>
                        
                    </div>
                    <h1>阮一峰老师博客阅读记录</h1>
                    <h2 class="subheading">深入浅出、收获颇多</h2>
                    <span class="meta">
                        Posted by mingrutough on
                        2017-12-13
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
    <!-- Post Container -->
            <div class="
                col-lg-8
                col-md-8
                col-md-offset-1
                col-md-offset-1                                                
                post-container">

                <h3 id="1-CommonJS规范-amp-amp-amp-require-源码解读-amp-amp-amp-AMD规范"><a href="#1-CommonJS规范-amp-amp-amp-require-源码解读-amp-amp-amp-AMD规范" class="headerlink" title="1.CommonJS规范&amp;&amp;&amp;require() 源码解读&amp;&amp;&amp;AMD规范"></a><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">1.CommonJS规范</a>&amp;&amp;&amp;<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="external">require() 源码解读</a>&amp;&amp;&amp;<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">AMD规范</a></h3><p>Node应用由模块组成，采用CommonJS模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// example.js</span></div><div class="line"><span class="comment">// 代码中的变量x和addX，是当前文件私有的，其他文件不可见。</span></div><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value + x;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果想在多个文件分享变量，必须定义为global对象的属性
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 当然，这样的写法是不推荐的</span></div><div class="line">global.warning = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// exmaple.js    代码通过module.exports输出变量x和函数addX。</span></div><div class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line">    <span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value + x;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">module</span>.exports.x = x;</div><div class="line">    <span class="built_in">module</span>.exports.addX = addX;</div><div class="line"></div><div class="line">    <span class="comment">// 相同目录下的另一个文件 main.js</span></div><div class="line">    <span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</div><div class="line">    <span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></div><div class="line">    <span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>CommonJS规范中，模块都通过require语句加载。</p>
<blockquote>
<p>当node遇到require(x)时，按下面的顺序处理</p>
<ol>
<li>如果x是内置模块(比如 require(‘http’))<br>
a.返回该模块；b.不再继续执行。</li>
<li><p>如果x以’./‘或者’/‘或者’../‘开头<br>
a.根据x所在的父模块，确定x的绝对路径。<br>
b.将x当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">* x;</div><div class="line">* x.js;</div><div class="line">* x.json;</div><div class="line">* x.node;</div></pre></td></tr></table></figure>
<p>c.将 x 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">x/package.json（main字段）</div><div class="line">x/index.js</div><div class="line">x/index.json</div><div class="line">x/index.node</div></pre></td></tr></table></figure>
</li>
<li><p>如果x不带路径 <br>
a. 根据 x 所在的父模块，确定 x 可能的安装目录。 <br>
b. 依次在每个目录中，将 x 当成文件名或目录名加载。</p>
</li>
<li><p>抛出 “not found”</p>
</li>
</ol>
</blockquote>
<h4 id="Module构造函数"><a href="#Module构造函数" class="headerlink" title="Module构造函数"></a>Module构造函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.exports = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    <span class="keyword">this</span>.filename = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">this</span>.children = [];</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = Module;</div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</div><div class="line"></div><div class="line"><span class="comment">// 上面代码中，Node定义了一个构造函数Moudle，所有的模块都是Module的实例。</span></div></pre></td></tr></table></figure>
<p>每个模块实例都有一个require方法。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 由此可知，require并不是全局性命令，而是每个模块提供的一个内部方法。另外，require 其实内部调用 Module._load 方法。</span></div></pre></td></tr></table></figure></p>
<p>下面来看 Module._load 源码
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>)</span>&#123;</div><div class="line">      <span class="comment">//  计算绝对路径</span></div><div class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent);</div><div class="line"></div><div class="line">  <span class="comment">//  第一步：如果有缓存，取出缓存</span></div><div class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</div><div class="line">  <span class="keyword">if</span> (cachedModule) </div><div class="line">    <span class="keyword">return</span> cachedModule.exports;</div><div class="line"></div><div class="line">  <span class="comment">// 第二步：是否为内置模块</span></div><div class="line">  <span class="keyword">if</span> (NativeModule.exists(filename)) &#123;</div><div class="line">    <span class="keyword">return</span> NativeModule.require(filename);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 第三步：生成模块实例，存入缓存</span></div><div class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</div><div class="line">  Module._cache[filename] = <span class="built_in">module</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 第四步：加载模块</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">module</span>.load(filename);</div><div class="line">    hadException = <span class="literal">false</span>;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (hadException) &#123;</div><div class="line">      <span class="keyword">delete</span> Module._cache[filename];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 第五步：输出模块的exports属性</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面来看模块是如何加载的,即module.load方法
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</div><div class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</div><div class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</div><div class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。</span></div><div class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">module</span>._compile(stripBOM(content), filename);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(stripBOM(content));</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    err.message = filename + <span class="string">': '</span> + err.message;</div><div class="line">    <span class="keyword">throw</span> err;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>module._compile 方法用于模块的编译。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = [self.exports, <span class="built_in">require</span>, self, filename, dirname];</div><div class="line">  <span class="keyword">return</span> compiledWrapper.apply(self.exports, args);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码基本等同于下面的形式
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</div><div class="line">  <span class="comment">// 模块源码</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>也就是说，模块加载的实质就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的exports变量的值输出。</strong></p>
<p>CommonJS模块的特点如下：</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性。</p>
<ul>
<li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li>module.filename 模块的文件名，带有绝对路径。</li>
<li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li>
<li>module.parent 返回一个对象，表示调用该模块的模块。</li>
<li>module.children 返回一个数组，表示该模块要用到的其他模块。</li>
<li>module.exports 表示模块对外输出的值。</li>
</ul>
<h5 id="module-exports属性"><a href="#module-exports属性" class="headerlink" title="module.exports属性"></a>module.exports属性</h5><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>
<h5 id="exports变量"><a href="#exports变量" class="headerlink" title="exports变量"></a>exports变量</h5><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</div></pre></td></tr></table></figure></p>
<h5 id="require-main"><a href="#require-main" class="headerlink" title="require.main"></a>require.main</h5><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身。</p>
<h4 id="模块的缓存"><a href="#模块的缓存" class="headerlink" title="模块的缓存"></a>模块的缓存</h4><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 删除指定模块的缓存</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.cache[moduleName];</div><div class="line"></div><div class="line"><span class="comment">// 删除所有模块的缓存</span></div><div class="line"><span class="built_in">Object</span>.keys(<span class="built_in">require</span>.cache).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">delete</span> <span class="built_in">require</span>.cache[key];</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<h4 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h4><p>AMD 是”Asynchronous Module Definition”的缩写。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
<br>
AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数:
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</div><div class="line"><span class="comment">// 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。</span></div></pre></td></tr></table></figure></p>
<p>require.js库完美的实现了AMD规范，下面将介绍require.js的基本用法。</p>
<h4 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h4><blockquote>
<p>require.js的诞生解决了两个主要问题:</p>
<ol>
<li>实现js文件的异步加载，避免网页失去响应。</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ol>
</blockquote>
<h5 id="require-js的加载"><a href="#require-js的加载" class="headerlink" title="require.js的加载"></a>require.js的加载</h5><figure class="highlight html"><table><tr><td class="code"><pre><div class="line">// data-main属性的作用是，指定网页程序的主模块。在下例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span>  <span class="attr">data-main</span>=<span class="string">"js/main"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="主模块的写法"><a href="#主模块的写法" class="headerlink" title="主模块的写法"></a>主模块的写法</h5><p>主模块的意思是作为整个网页的入口代码。当主模块依赖于其他模块，这时就要使用AMD规范定义的require()函数。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line">　　<span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB, moduleC</span>)</span>&#123;</div><div class="line">　　　　<span class="comment">// some code here</span></div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<br>
<strong>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</strong> <br>
假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写:
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">　　<span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'underscore'</span>, <span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _, Backbone</span>)</span>&#123;</div><div class="line">　　　　<span class="comment">// some code here</span></div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a>模块的加载</h5><p>上面的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。
使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。<br>
具体示例见文章内。</p>
<h5 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a>AMD模块的写法</h5><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">　　<span class="comment">// math.js</span></div><div class="line">　　define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> x+y;</div><div class="line">　　　　&#125;;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　add: add</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;);</div><div class="line"><span class="comment">// 加载方法</span></div><div class="line">　　<span class="comment">// main.js</span></div><div class="line">　　<span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</div><div class="line">　　　　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">　　&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</span></div><div class="line"><span class="comment">// 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</span></div><div class="line"><span class="comment">// foo.js</span></div><div class="line">　　define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　myLib.doSomething();</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　foo : foo</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h5><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？
回答是可以的。具体示例见文章。</p>
<h4 id="AMD规范与CommonJS规范的兼容性"><a href="#AMD规范与CommonJS规范的兼容性" class="headerlink" title="AMD规范与CommonJS规范的兼容性"></a>AMD规范与CommonJS规范的兼容性</h4><ul>
<li>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</li>
<li>AMD规范则是非同步加载模块，允许指定回调函数。</li>
</ul>
<p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。<br>
AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样：
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> someModule = <span class="built_in">require</span>(<span class="string">"someModule"</span>);</div><div class="line">    <span class="keyword">var</span> anotherModule = <span class="built_in">require</span>(<span class="string">"anotherModule"</span>);</div><div class="line"></div><div class="line">    someModule.doTehAwesome();</div><div class="line">    anotherModule.doMoarAwesome();</div><div class="line"></div><div class="line">    exports.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        someModule.doTehAwesome();</div><div class="line">        anotherModule.doMoarAwesome();</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="2-网页性能管理"><a href="#2-网页性能管理" class="headerlink" title="2.网页性能管理"></a><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="external">2.网页性能管理</a></h3><blockquote>
<h4 id="网页生成的过程"><a href="#网页生成的过程" class="headerlink" title="网页生成的过程"></a>网页生成的过程</h4><p>网页的生成过程，大致可以分成五步。</p>
<ol>
<li>HTML代码转化为DOM。</li>
<li>CSS代码转化为CSSDOM(css object model)。</li>
<li>结合DOM和CSSDOM，生成一颗渲染树(包含每个节点的视觉信息)。</li>
<li>生成布局(layout)，即将所有渲染树的所有节点进行平面整合。</li>
<li>将布局绘制(paint)在屏幕上。
<br>
这五步中，第一步到第三步很快，耗时的是第四步和第五步。生成布局(flow)和绘制(paint)这两步，合称为“渲染”(render)。<img alt="浏览器渲染过程" src="http://outqqzk4u.bkt.clouddn.com/img/study/github_blog//images/ruanyifeng0.png">
</li>
</ol>
<h4 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h4><p>网页生成的时候，至少会渲染一次，用户访问的过程中，还会不断重新渲染。
<br>
以下三种情况，会导致网页重新渲染</p>
<ol>
<li>修改DOM</li>
<li>修改样式表</li>
<li>用户事件(比如鼠标悬停、页面滚动、输入框输入文字、改变窗口大小等)</li>
</ol>
<p><strong>重新渲染，就需要重新生成布局和重新绘制。前者叫做“重排”(reflow)，后者叫做“重绘”(repaint)</strong>。
<br>
需要注意的是，重绘不一定需要重排，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是重排必然会导致重绘，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。
<br></p>
<h4 id="对于性能的影响"><a href="#对于性能的影响" class="headerlink" title="对于性能的影响"></a>对于性能的影响</h4><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。
前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。</span></div><div class="line">div.style.color = <span class="string">'blue'</span>;</div><div class="line">div.style.marginTop = <span class="string">'30px'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果写得不好，就会触发两次重排和重绘。</span></div><div class="line"><span class="comment">// 代码中对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。</span></div><div class="line">div.style.color = <span class="string">'blue'</span>;</div><div class="line"><span class="keyword">var</span> margin = <span class="built_in">parseInt</span>(div.style.marginTop);</div><div class="line">div.style.marginTop = (margin + <span class="number">10</span>) + <span class="string">'px'</span>;</div></pre></td></tr></table></figure></p>
<p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">offsetTop/offsetLeft/offsetWidth/offsetHeight</div><div class="line">scrollTop/scrollLeft/scrollWidth/scrollHeight</div><div class="line">clientTop/clientLeft/clientWidth/clientHeight</div><div class="line">getComputedStyle()</div></pre></td></tr></table></figure></p>
<p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">div.style.left = div.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</div><div class="line">div.style.top = div.offsetTop + <span class="number">10</span> + <span class="string">"px"</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> left = div.offsetLeft;</div><div class="line"><span class="keyword">var</span> top  = div.offsetTop;</div><div class="line">div.style.left = left + <span class="number">10</span> + <span class="string">"px"</span>;</div><div class="line">div.style.top = top + <span class="number">10</span> + <span class="string">"px"</span>;</div></pre></td></tr></table></figure></p>
<p>一般的规则是:</p>
<ul>
<li>样式表越简单，重排和重绘就越快。</li>
<li>重排和重绘的DOM元素层级越高，成本就越高。</li>
<li>table元素的重排和重绘成本，要高于div元素</li>
</ul>
<h4 id="提高性能的九个技巧"><a href="#提高性能的九个技巧" class="headerlink" title="提高性能的九个技巧"></a>提高性能的九个技巧</h4><ol>
<li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li>
<li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li>
<li>不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</li>
<li>尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li>
<li>先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li>position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
<li>只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。</li>
<li>使用虚拟DOM的脚本库，比如React、vue等。</li>
<li>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。</li>
</ol>
</blockquote>
<h3 id="3-Module的语法-amp-amp-amp-Module的加载实现"><a href="#3-Module的语法-amp-amp-amp-Module的加载实现" class="headerlink" title="3.Module的语法&amp;&amp;&amp;Module的加载实现"></a>3.<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">Module的语法</a>&amp;&amp;&amp;<a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="external">Module的加载实现</a></h3><blockquote>
<p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
<br>
ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CommonJS模块</span></div><div class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">let</span> stat = _fs.stat;</div><div class="line"><span class="keyword">let</span> exists = _fs.exists;</div><div class="line"><span class="keyword">let</span> readfile = _fs.readfile;</div></pre></td></tr></table></figure></p>
<p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。<br> 
ES6模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ES6模块</span></div><div class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为”编译时加载”或者静态加载。即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。由于ES6模块是编译时加载，使得静态分析称为可能。</p>
</blockquote>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<h4 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h4><p>export命令用于规定模块的对外接口。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// profile.js  写法一</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"></div><div class="line"><span class="comment">// profile.js 写法二（推荐）</span></div><div class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div><div class="line"></div><div class="line"><span class="comment">//输出函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">  v1 <span class="keyword">as</span> streamV1,</div><div class="line">  v2 <span class="keyword">as</span> streamV2,</div><div class="line">  v2 <span class="keyword">as</span> streamLatestVersion</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">export</span> <span class="number">1</span>;</div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> m;</div><div class="line"><span class="comment">// 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。</span></div><div class="line"></div><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;m&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>注意，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</strong>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p>import命令用于输入其他模块提供的功能。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果想为输入的变量重新去一个名字，</span></div><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</span></div><div class="line"><span class="comment">// 下面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是在编译阶段执行的，在代码运行前。</span></div><div class="line">foo();</div><div class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</span></div><div class="line"><span class="comment">// 下面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。</span></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</div><div class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</div><div class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 最后，import语句会执行所加载的模块，因此可以有下面的写法。</span></div><div class="line"><span class="comment">// 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。</span></div><div class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</div></pre></td></tr></table></figure></p>
<h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><p>除了指定加载某个输出值，还可以使用整体加载，即用(*)指定一个对象，所有输出值都加载在这个对象上。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// circle.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</div><div class="line"></div><div class="line"><span class="comment">//整体加载的方式</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</div><div class="line"></div><div class="line"><span class="comment">// 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。</span></div></pre></td></tr></table></figure></p>
<h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><p>export default 用于为模块指定默认输出。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// import-default.js</span></div><div class="line"><span class="comment">// 下面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。</span></div><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line">customName(); <span class="comment">// 'foo'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string">注意，export default命令用于指定模块的默认输出。显然，一个模块只有一个默认输出，因此，export default命令只能使用一次。所以import命令后面才不用加大括号，因为只可能对应一个方法。&lt;br&gt;</span></div><div class="line"><span class="string">有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例</span></div><div class="line"><span class="string">`</span><span class="string">``</span>js</div><div class="line"><span class="comment">// 输入默认接口</span></div><div class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 同时输入默认方法和其他接口</span></div><div class="line"><span class="keyword">import</span> _, &#123; each, each <span class="keyword">as</span> forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 对应上面代码的export语句如下。</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// ···</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// ···</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; each <span class="keyword">as</span> forEach &#125;;</div></pre></td></tr></table></figure></p>
<h4 id="export和import的复合写法"><a href="#export和import的复合写法" class="headerlink" title="export和import的复合写法"></a>export和import的复合写法</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</div><div class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</div><div class="line"></div><div class="line"><span class="comment">//模块的接口改名和整体输出，也可以采用这种写法。</span></div><div class="line"><span class="comment">// 接口改名</span></div><div class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 整体输出</span></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</div></pre></td></tr></table></figure>
<h4 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 模块之间也可以继承。假设有一个circleplus模块，继承了circle模块。</span></div><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 上面代码中的export *，表示再输出circle模块的所有属性和方法。</span></div><div class="line"><span class="comment">//注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</span></div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'circleplus'</span>;</div><div class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'circleplus'</span>; <span class="comment">// 将circleplus模块的默认方法加载为exp方法。</span></div><div class="line"><span class="built_in">console</span>.log(exp(math.e));</div></pre></td></tr></table></figure>
<h4 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h4><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</div><div class="line"><span class="comment">// constants.js 模块</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">// test1.js 模块</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</div><div class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="comment">// test2.js 模块</span></div><div class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</div><div class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p>由于import命令会被JS引擎静态分析，先与模块内的其他语句执行。所以import命令无法完成下面的动态加载功能。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</div><div class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path);</div></pre></td></tr></table></figure></p>
<p>import()函数的出现，是为了解决es6模块的动态加载功能。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span>(specifier);</div><div class="line"><span class="comment">// import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。</span></div><div class="line"></div><div class="line"><span class="comment">//import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。</span></div></pre></td></tr></table></figure></p>
<h5 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h5><ol>
<li><p>按需加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</span></div><div class="line">button.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./dialogBox.js'</span>)</div><div class="line">  .then(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</div><div class="line">    dialogBox.open();</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">/* Error handling */</span></div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>条件加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// import()可以放在if代码块，根据不同的情况，加载不同的模块。</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  <span class="keyword">import</span>(<span class="string">'moduleA'</span>).then(...);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">import</span>(<span class="string">'moduleB'</span>).then(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>动态的模块路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// import()允许模块路径动态生成。代码中，根据函数f的返回结果，加载不同的模块。</span></div><div class="line"><span class="keyword">import</span>(f())</div><div class="line">.then(...);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码中，export1和export2都是myModule.js的输出接口，可以解构获得。</span></div><div class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</div><div class="line">.then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...·</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 如果模块有default输出接口，可以用参数直接获得。</span></div><div class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</div><div class="line">.then(<span class="function"><span class="params">myModule</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(myModule.default);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</div><div class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</div><div class="line">])</div><div class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</div><div class="line">   ···</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// mport()也可以用在 async 函数之中。</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</div><div class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</div><div class="line">  <span class="keyword">const</span> [module1, module2, module3] =</div><div class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</div><div class="line">      <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</div><div class="line">      <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</div><div class="line">      <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</div><div class="line">    ]);</div><div class="line">&#125;</div><div class="line">main();</div></pre></td></tr></table></figure></p>
<h4 id="浏览器加载ES6模块的规则"><a href="#浏览器加载ES6模块的规则" class="headerlink" title="浏览器加载ES6模块的规则"></a>浏览器加载ES6模块的规则</h4><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type="module"属性--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>浏览器对于带有type=”module”的script，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script标签的defer属性。</p>
<h4 id="ES6模块和CommonJS模块的差异"><a href="#ES6模块和CommonJS模块的差异" class="headerlink" title="ES6模块和CommonJS模块的差异"></a>ES6模块和CommonJS模块的差异</h4><ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<blockquote>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
</blockquote>
</li>
</ul>
<h3 id="4-Git工作流程"><a href="#4-Git工作流程" class="headerlink" title="4.Git工作流程"></a><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">4.Git工作流程</a></h3><blockquote>
<p>文章将涉及三种广泛使用的工作流程: Git flow 、Github flow 、Gitlab flow。这三种工作流程都有一个共同点: 都采用”功能驱动式开发”。它指的是，需求是开发的起点，现有需求再有功能分支(feature branch)或者补丁分支(hotfix branch)。完成开发后，该分支就合并到主分支，然后被删除。</p>
</blockquote>
<h4 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git  flow"></a>Git  flow</h4><p>首先，项目存在两个长期分支:</p>
<ul>
<li>主分支 master</li>
<li>开发分支 develop</li>
</ul>
<p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。其次，项目存在三种短期分支。</p>
<ul>
<li>功能分支(feature branch)</li>
<li>补丁分支(hotfix branch)</li>
<li>预发分支(release branch)</li>
</ul>
<p>一旦完成开发，它们就被合并进develop或master，然后被删除。
评价: 优点是清晰可控，缺点是相对复杂，同时需要维护两个长期分支。更大的问题是这个模式是基于”版本发布”的，但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这是，master分支和develop分支的差别不大。</p>
<h4 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h4><p>Github flow 是Git flow的简化版，专门配合’持续发布’。<br>
它只有一个长期分支，就是master</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/05/02/高性能网站建设指南/" data-toggle="tooltip" data-placement="top" title="高性能网站建设指南">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2017/11/06/ruanyifeng-webpack/" data-toggle="tooltip" data-placement="top" title="Webpack各种资源学习">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-3
                col-md-3
                col-md-offset-0
                col-md-offset-0
                hidden-xs	
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">目录</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                          <a class="tag" href="/tags/#大牛博客" title="大牛博客">大牛博客</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    // async("https://cdn.bootcss.com/anchor-js/4.1.0/anchor.min.js",function(){
    //     anchors.options = {
    //       visible: 'always',
    //       placement: 'left',
    //       icon: ''
    //     };
    //     // anchors.add();
    //     // anchors.add('.post-container h1, .post-container h2, .post-container h3, .post-container h4');
    //     simpleNav();
    // })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>




    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Mingru’s Blog 2018 
                    <br>
                    <!--Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>-->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.js"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://mingrutough.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        console.log(a);
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        // $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: true,
            easing: "swing",
            filter: "",
            scrollSpeed: 500,
            scrollOffset: 0,
            scrollThreshold: .5,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });    

    function catalogPosition(){
        
    };
    var catTopDis = $('.catalog-container').offset().top; // 导航距离顶部距离(position不为fixed时) 
    var catLeftDis = $('.catalog-container').offset().left; // 导航距离顶部距离(position不为fixed时)  
    navFixed();
    $(document).on('scroll',navFixed);
    function navFixed(){ // 根据当前页面滚动情况固定导航栏
        var scrollHeight = $(document).scrollTop();         
        if(scrollHeight > catTopDis){
            if(!$('.catalog-container').hasClass('catalog-fixed')) {
                $('.catalog-container').addClass('catalog-fixed').css('left',catLeftDis); ;
            } 
                
        } else{
            if($('.catalog-container').hasClass('catalog-fixed')) {                       
                $('.catalog-container').removeClass('catalog-fixed').css('left',0); ;

            } 
        }
    }
    // $(window).on('resize',function(){
    //     catTopDis = $('.catalog-container').offset().top; // 导航距离顶部距离(position不为fixed时) 
    //     catLeftDis = $('.catalog-container').offset().left; // 导航距离顶部距离(position不为fixed时)  
    // });
</script>




<!-- Image to hack wechat -->
<!--<img src="https://mingrutough.github.io/img/icon_wechat.png" width="0" height="0" />-->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
